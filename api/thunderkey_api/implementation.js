// Â© 2021 Sarah Forest and George Hill
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

////////////////////////////////////////////////////////////////////////////////

// The following file was adapted from the "experiment" sample
// Thunderbird extension provided here:
// https://github.com/thundernest/sample-extensions

////////////////////////////////////////////////////////////////////////////////

/* eslint-disable object-shorthand */

// Get various parts of the WebExtension framework that we need.
var { ExtensionCommon } = ChromeUtils.import("resource://gre/modules/ExtensionCommon.jsm");

// You probably already know what this does.
var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

// ChromeUtils.import() works in experiments for core resource urls as it did
// in legacy add-ons. However, chrome:// urls that point to add-on resources no
// longer work, as the "chrome.manifest" file is no longer supported, which
// defined the root path for each add-on. Instead, ChromeUtils.import() needs
// a url generated by 
// 
// let url = context.extension.rootURI.resolve("path/to/file.jsm")
//
// Instead of taking the extension object from the context, you may generate
// the extension object from a given add-on ID as shown in the example below.
// This allows to import a JSM without context, for example inside another JSM.
//
var { ExtensionParent } = ChromeUtils.import("resource://gre/modules/ExtensionParent.jsm");
var extension = ExtensionParent.GlobalManager.getExtension("thunderkey@example.com");
// var { myModule } = ChromeUtils.import(extension.rootURI.resolve("src/modules/myModule.jsm"));

// This is the important part. It implements the functions and events defined in schema.json.
// The variable must have the same name you've been using so far, "thunderkey_api" in this case.
var thunderkey_api = class extends ExtensionCommon.ExtensionAPI {
    getAPI(context) {
        return {
            // Again, this key must have the same name.
            thunderkey_api: {

                // A function.
                sayHello: async function (name) {
                    // myModule.incValue();
                    // Services.wm.getMostRecentWindow("mail:3pane").alert("Hello " + name + "! I counted <" + myModule.getValue() + "> clicks so far.");
                },

                // An event. Most of this is boilerplate you don't need to worry about, just copy it.
                onToolbarClick: new ExtensionCommon.EventManager({
                    context,
                    name: "thunderkey_api.onToolbarClick",
                    // In this function we add listeners for any events we want to listen to, and return a
                    // function that removes those listeners. To have the event fire in your extension,
                    // call fire.async.
                    register(fire) {
                        function callback(event, id, x, y) {
                            return fire.async(id, x, y);
                        }

                        windowListener.add(callback);
                        return function () {
                            windowListener.remove(callback);
                        };
                    },
                }).api(),

                ////////////////////////////////////////////////////////////////

                // GH: 2021-06-29: Our first new function is added here . . .
                getManuallySortFoldersSortOrderData:
                    getManuallySortFoldersSortOrderDataFunction,

                // GH: 2021-07-07: Our second addition is added here . . .
                onAnyKeydown: new ExtensionCommon.EventManager({
                    context,
                    name: "thunderkey_api.onAnyKeydown",
                    // In this function we add listeners for any events we want to listen to, and return a
                    // function that removes those listeners. To have the event fire in your extension,
                    // call fire.async.
                    register(fire) {
                        function callback(event, pressedKey, view) {
                            return fire.async(pressedKey, view);
                        }

                        keydownWindowListener.add(callback);
                        return function () {
                            keydownWindowListener.remove(callback);
                        };
                    },
                }).api(),

                ////////////////////////////////////////////////////////////////
            },
        };
    }

    onShutdown(isAppShutdown) {
        // This function is called if the extension is disabled or removed, or Thunderbird closes.
        // We usually do not have to do any cleanup, if Thunderbird is shutting down entirely
        if (isAppShutdown) {
            return;
        }
        // console.log("Goodbye world!");

        // Unload the JSM we imported above. This will cause Thunderbird to forget about the JSM, and
        // load it afresh next time `import` is called. (If you don't call `unload`, Thunderbird will
        // remember this version of the module and continue to use it, even if your extension receives
        // an update.) You should *always* unload JSMs provided by your extension.
        // Cu.unload(extension.rootURI.resolve("modules/myModule.jsm"));

        // Thunderbird might still cache some of your JavaScript files and even if JSMs have been unloaded,
        // the last used version could be reused on next load, ignoring any changes. Get around this issue
        // by invalidating the caches (this is identical to restarting TB with the -purgecaches parameter):
        Services.obs.notifyObservers(null, "startupcache-invalidate", null);
    }
};

// A helpful class for listening to windows opening and closing.
// (This file had a lowercase E in Thunderbird 65 and earlier.)
var { ExtensionSupport } = ChromeUtils.import("resource:///modules/ExtensionSupport.jsm");

// This object is just what we're using to listen for toolbar clicks. The implementation isn't
// what this example is about, but you might be interested as it's a common pattern. We count the
// number of callbacks waiting for events so that we're only listening if we need to be.
var windowListener = new class extends ExtensionCommon.EventEmitter {
    constructor() {
        super();
        this.callbackCount = 0;
    }

    handleEvent(event) {
        let toolbar = event.target.closest("toolbar");
        windowListener.emit("toolbar-clicked", toolbar.id, event.clientX, event.clientY);
    }

    add(callback) {
        this.on("toolbar-clicked", callback);
        this.callbackCount++;

        if (this.callbackCount == 1) {
            ExtensionSupport.registerWindowListener("experimentListener", {
                chromeURLs: [
                    "chrome://messenger/content/messenger.xhtml",
                    "chrome://messenger/content/messenger.xul",
                ],
                onLoadWindow: function (window) {
                    let toolbox = window.document.getElementById("mail-toolbox");
                    toolbox.addEventListener("click", windowListener.handleEvent);
                },
            });
        }
    }

    remove(callback) {
        this.off("toolbar-clicked", callback);
        this.callbackCount--;

        if (this.callbackCount == 0) {
            for (let window of ExtensionSupport.openWindows) {
                if ([
                    "chrome://messenger/content/messenger.xhtml",
                    "chrome://messenger/content/messenger.xul",
                ].includes(window.location.href)) {
                    let toolbox = window.document.getElementById("mail-toolbox");
                    toolbox.removeEventListener("click", this.handleEvent);
                }
            }
            ExtensionSupport.unregisterWindowListener("experimentListener");
        }
    }
};

////////////////////////////////////////////////////////////////////////////////

async function getManuallySortFoldersSortOrderDataFunction() {
    // GH: 2021-06-29: The following code block is adapted from the
    // "Manually sort folders" extension.
    // https://addons.thunderbird.net/en-US/thunderbird/addon/manually-sort-folders/
    let tbsf_prefs = {};
    try {
        tbsf_prefs =
            Services.prefs.getBranch("extensions.tbsortfolders@xulforum.org.");
    } catch (error) {
        // console.log(`Error: ${error}`);
    }
    let tbsf_data = {};
    try {
        tbsf_data = JSON.parse(tbsf_prefs.getStringPref("tbsf_data"));
    } catch (error) {
        // console.log(`Error: ${error}`);
    }

    // GH: 2021-06-29: The following lines are from "Manually sort folders" but
    // are no longer needed; they are for reference only.
    var tbsf_prefs_functions;
    function update_prefs_functions() {
        tbsf_prefs_functions = Object();
        for (let vkey in tbsf_data) {
            let key = vkey;
            /* key[0] = 0 if the user asked for Tb's default sort function, 1 for
                alphabetical, 2 for custom sort
               key[1] = the data to pass to tbsf_sort_functions[2] if key[0] == 2
            */
            if (tbsf_data[key][0] == 2) {
                //feed the manual sort function with the associated sort data
                tbsf_prefs_functions[key] = (a, b) => tbsf_sort_functions[2](tbsf_data[key][1], a, b);
            } else {
                //other functions don't need specific data
                tbsf_prefs_functions[key] = tbsf_sort_functions[tbsf_data[key][0]];
            }
        }
    }
    // update_prefs_functions();

    // GH: 2021-06-30: The following is new. We need to simplify the data in
    // tbsf_data:
    for (const accountName in tbsf_data) {
        if (tbsf_data[accountName][0] === undefined) {
            tbsf_data[accountName][0] = "0"; // Prevents bug.
        }
        let newObject = {};
        for (const key in tbsf_data[accountName][1]) {
            // key === "imap://user@example.com/INBOX"
            const reducedKey = key.split("://")[1];
            // reducedKey === "user@example.com/INBOX";
            const firstSlashIndex = reducedKey.indexOf("/");
            const newKey = reducedKey.substr(firstSlashIndex);
            // newKey === "/INBOX"
            newObject[newKey] = tbsf_data[accountName][1][key];
        }
        tbsf_data[accountName][1] = { ...newObject };
    }

    return tbsf_data;
}

////////////////////////////////////////////////////////////////////////////////

// Adapted from the "windowListener" code above.
var keydownWindowListener = new class extends ExtensionCommon.EventEmitter {
    constructor() {
        super();
        this.callbackCount = 0;
    }

    handleEvent(event) {
        // Here begins some code that is repeated in src/options/options.js.
        const keyCombination = convertEventToKeyCombination(event);

        function convertEventToKeyCombination(event) {
            if (
                event.key === "Alt" ||
                event.key === "Control" ||
                event.key === "Meta" ||
                event.key === "Shift"
            ) {
                return "";
            }

            let keyCombinationArray = [];

            if (event.altKey) keyCombinationArray.push("Alt");
            if (event.ctrlKey) keyCombinationArray.push("Ctrl");
            if (event.metaKey) keyCombinationArray.push("Meta");
            if (event.shiftKey) keyCombinationArray.push("Shift");

            keyCombinationArray.push(event.key);

            const keyCombination = keyCombinationArray.join("+")

            return keyCombination;
        }
        // Here ends the code that is repeated.

        if (keyCombination === "") return;

        if (event.target.tagName === "search-textbox") return;

        const path = event.view.location.href;

        keydownWindowListener.emit("keypress", keyCombination, path);
    }

    add(callback) {
        this.on("keypress", callback);
        this.callbackCount++;

        if (this.callbackCount == 1) {
            ExtensionSupport.registerWindowListener("keydownListener", {
                chromeURLs: [
                    "chrome://messenger/content/messenger.xhtml",
                    "chrome://messenger/content/messenger.xul",
                    "chrome://messenger/content/messengercompose/messengercompose.xhtml",
                    "chrome://messenger/content/messengercompose/messengercompose.xul",
                    "chrome://messenger/content/messageWindow.xhtml",
                    "chrome://messenger/content/messageWindow.xul",
                ],
                onLoadWindow: function (window) {
                    window.addEventListener("keydown", keydownWindowListener.handleEvent);
                },
            });
        }
    }

    remove(callback) {
        this.off("keypress", callback);
        this.callbackCount--;

        if (this.callbackCount == 0) {
            for (let window of ExtensionSupport.openWindows) {
                if ([
                    "chrome://messenger/content/messenger.xhtml",
                    "chrome://messenger/content/messenger.xul",
                    "chrome://messenger/content/messengercompose/messengercompose.xhtml",
                    "chrome://messenger/content/messengercompose/messengercompose.xul",
                    "chrome://messenger/content/messageWindow.xhtml",
                    "chrome://messenger/content/messageWindow.xul",
                ].includes(window.location.href)) {
                    window.removeEventListener("keydown", this.handleEvent);
                }
            }
            ExtensionSupport.unregisterWindowListener("keydownListener");
        }
    }
};
